local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

local Window = WindUI:CreateWindow({
    Title = "RaZui Hub",
    Folder = "MySuperHub",
    Size = UDim2.fromOffset(580, 460),
    MinSize = Vector2.new(560, 350),
    MaxSize = Vector2.new(850, 560),
    Transparent = true,
    Theme = "Dark",
    Resizable = true,
    SideBarWidth = 150,
    BackgroundImageTransparency = 0.42,
    HideSearchBar = true,
    ScrollBarEnabled = false,
})

Window:SetToggleKey(Enum.KeyCode.K)
Window:EditOpenButton({
    Title = "Open UI",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29")),
    OnlyMobile = false,
    Enabled = true,
    Draggable = true,
})

--------------------------------------------------------------------------------
-- SERVICES & UTILS
--------------------------------------------------------------------------------
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualInputManager = game:GetService("VirtualInputManager")
local GuiService = game:GetService("GuiService")
local Workspace = game:GetService("Workspace")

local lp = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Debris = Workspace:WaitForChild("Debris")
local PlayerGui = lp:WaitForChild("PlayerGui")
-- Attempt to get ForgeUI, might not exist yet if fresh spawn
local ForgeUI = PlayerGui:WaitForChild("Forge", 5) 

local MOVEMENT_SPEED = 65 
local NoclipConnection = nil

-- 1. NOCLIP
local function SetNoclip(state)
    if state then
        if not NoclipConnection then
            NoclipConnection = RunService.Stepped:Connect(function()
                if lp.Character then
                    for _, part in pairs(lp.Character:GetDescendants()) do
                        if part:IsA("BasePart") and part.CanCollide == true then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        end
    else
        if NoclipConnection then
            NoclipConnection:Disconnect()
            NoclipConnection = nil
        end
    end
end

-- 2. FLOAT (For NPCs)
local function ToggleFloat(state)
    if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = lp.Character.HumanoidRootPart
    local hum = lp.Character:FindFirstChild("Humanoid")

    if state then
        if hum then hum.PlatformStand = true end
        if not hrp:FindFirstChild("FarmFloat") then
            local bv = Instance.new("BodyVelocity")
            bv.Name = "FarmFloat"
            bv.Velocity = Vector3.new(0, 0, 0)
            bv.MaxForce = Vector3.new(100000, 100000, 100000)
            bv.Parent = hrp
        end
    else
        if hum then hum.PlatformStand = false end
        local bv = hrp:FindFirstChild("FarmFloat")
        if bv then bv:Destroy() end
    end
end

-- 3. TWEEN MOVEMENT
local function TweenTo(targetCFrame)
    if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then return end
    local hrp = lp.Character.HumanoidRootPart
    
    local distance = (hrp.Position - targetCFrame.Position).Magnitude
    local time = distance / MOVEMENT_SPEED
    
    -- If very close, just snap
    if distance < 5 then
        hrp.CFrame = targetCFrame
        return
    end

    SetNoclip(true)
    ToggleFloat(true) 

    local tweenInfo = TweenInfo.new(time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    local tween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    
    tween:Play()
    
    local completed = false
    local conn = tween.Completed:Connect(function() completed = true end)
    
    while not completed do
        if not _G.AutoFarm and not _G.AutoCaveEnabled and not _G.AutoOreEnabled and not _G.TeleportToggleActive then
            tween:Cancel()
            ToggleFloat(false)
            break
        end
        task.wait()
    end
    
    if conn then conn:Disconnect() end
end

--------------------------------------------------------------------------------
-- FARM TAB (NPCS)
--------------------------------------------------------------------------------
local FarmTab = Window:Tab({Title = "Farm"})
FarmTab:Select()

local Section = FarmTab:Section({ Title = "Farm Mobs" })

_G.SelectedNPCs = { "Skeleton Rogue" }

local function GetBaseName(displayName)
    if not displayName then return "" end
    return displayName:match("^(.-)%s*%(Level:") or displayName
end

FarmTab:Dropdown({
    Title = "Select MOBs to Farm",
    Values = {
        "Skeleton Rogue", "Axe Skeleton", "Deathaxe Skeleton", "Bomber",
        "Slime", "Blazing Slime", "Elite Rogue Skeleton", "Elite Deathaxe Skeleton", "Reaper"
    },
    Value = { "Skeleton Rogue" },
    Multi = true,
    AllowNone = true,
    Callback = function(optionsTable) 
        _G.SelectedNPCs = optionsTable or {}
    end
})

FarmTab:Toggle({
    Title = "Auto Farm MOBs",
    Desc = "Targets Nearest MOB",
    Value = false,
    Callback = function(state)
        _G.AutoFarm = state
        
        if not state then
            SetNoclip(false)
            ToggleFloat(false)
            return
        end

        task.spawn(function()
            while _G.AutoFarm do
                if #_G.SelectedNPCs == 0 then
                    ToggleFloat(false)
                    task.wait(1)
                    continue
                end
                
                -- FIND NEAREST NPC LOGIC
                local target = nil
                local shortestDist = math.huge
                local myPos = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") and lp.Character.HumanoidRootPart.Position

                if myPos and workspace:FindFirstChild("Living") then
                    for _, v in pairs(workspace.Living:GetChildren()) do
                        if v:GetAttribute("IsNpc") == true and v:FindFirstChild("Humanoid") and v:FindFirstChild("HumanoidRootPart") then
                            local h = v.Humanoid
                            if h.Health > 0 then
                                local baseName = GetBaseName(h.DisplayName)
                                -- Check validity against selection
                                local match = false
                                for _, s in ipairs(_G.SelectedNPCs) do
                                    if s == baseName then match = true break end
                                end
                                
                                if match then
                                    local dist = (myPos - v.HumanoidRootPart.Position).Magnitude
                                    if dist < shortestDist then
                                        shortestDist = dist
                                        target = v
                                    end
                                end
                            end
                        end
                    end
                end

                -- ATTACK LOGIC
                if target then
                    local tRoot = target.HumanoidRootPart
                    local attackCFrame = tRoot.CFrame * CFrame.new(0, -7, 0) 
                    attackCFrame = CFrame.lookAt(attackCFrame.Position, tRoot.Position)

                    TweenTo(attackCFrame)
                    ToggleFloat(true) 
                    SetNoclip(true)

                    while _G.AutoFarm and target and target.Parent and target.Humanoid.Health > 0 do
                        if not lp.Character then break end
                        
                        -- Keep position relative to enemy
                        local tPos = tRoot.Position
                        local goalPos = tRoot.CFrame * CFrame.new(0, -7, 0)
                        lp.Character.HumanoidRootPart.CFrame = CFrame.lookAt(goalPos.Position, tPos)
                        lp.Character.HumanoidRootPart.Velocity = Vector3.zero

                        -- Equip
                        local char = lp.Character
                        if not char:FindFirstChildWhichIsA("Tool") then
                            local tool = lp.Backpack:FindFirstChild("Weapon") or lp.Backpack:FindFirstChildWhichIsA("Tool")
                            if tool then char.Humanoid:EquipTool(tool) end
                        end

                        -- Swing
                        pcall(function()
                            game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ToolService.RF.ToolActivated:InvokeServer("Weapon")
                        end)
                        task.wait()
                    end
                else
                    ToggleFloat(false)
                    task.wait(0.5)
                end
                task.wait()
            end
            ToggleFloat(false)
            SetNoclip(false)
        end)
    end
})

--------------------------------------------------------------------------------
-- ORE / CAVE FARMING (ANCHORED & NEAREST)
--------------------------------------------------------------------------------

local Section = FarmTab:Section({ Title = "Farm Caves" })
local ToolService = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("ToolActivated")

-- CAVE DATA
local caves = {
    ["Start Cave"] = { folders = {"Island2CaveStart"}, ores = {"Basalt Rock"} },
    ["Middle Cave"] = { folders = {"Island2CaveMid"}, ores = {"Basalt Rock"} },
    ["Danger Cave"] = { folders = {"Island2CaveDanger1", "Island2CaveDanger2", "Island2CaveDanger3", "Island2CaveDanger4", "Island2CaveDangerClosed"}, ores = {"Basalt Rock", "Basalt Core", "Basalt Vein"} },
    ["Deep Cave"] = { folders = {"Island2CaveDeep"}, ores = {"Basalt Rock", "Basalt Core", "Basalt Vein"} },
    ["Goblin Cave"] = { folders = {"Island2GoblinCave"}, ores = {"Basalt Rock", "Basalt Core", "Basalt Vein", "Earth Crystal", "Crimson Crystal", "Cyan Crystal", "Light Crystal" } },
    ["Volcanic Depths"] = { folders = {"Island2VolcanicDepths", "Island2CaveLavaClosed"}, ores = {"Basalt Core", "Basalt Vein", "Volcanic Rock"} }
}

local allOres = {"Basalt Rock", "Basalt Core", "Basalt Vein", "Volcanic Rock", "Earth Crystal", "Crimson Crystal", "Cyan Crystal", "Light Crystal"}

-- HELPER: Validate Rock
local function isRockValid(model, oreList)
    if not model or not model.Parent then return false end
    
    -- Name Check
    local nameMatch = false
    if oreList then
        for _, name in ipairs(oreList) do
            if model.Name == name or model:FindFirstChild(name) then nameMatch = true break end
        end
    else
        nameMatch = true
    end
    if not nameMatch then return false end

    -- Health Check
    local hPart = nil
    for _, c in ipairs(model:GetChildren()) do
        if c:GetAttribute("Health") then hPart = c break end
    end
    
    if hPart then
        local hp = hPart:GetAttribute("Health")
        return hp and hp > 0
    end
    return false
end

-- HELPER: Find Nearest Rock (Scans folders)
local function FindNearestOre(mode)
    local rFolder = workspace:FindFirstChild("Rocks")
    if not rFolder then return nil end
    if not lp.Character or not lp.Character:FindFirstChild("HumanoidRootPart") then return nil end

    local myPos = lp.Character.HumanoidRootPart.Position
    local bestRock = nil
    local closestDist = math.huge

    if mode == "Cave" then
        local data = caves[_G.SelectedCave or "Start Cave"]
        if data and data.folders then
            -- Scan ALL folders belonging to this cave definition
            for _, folderName in ipairs(data.folders) do
                local f = rFolder:FindFirstChild(folderName)
                if f then
                    for _, v in ipairs(f:GetChildren()) do
                        if isRockValid(v, data.ores) then 
                            local dist = (v:GetPivot().Position - myPos).Magnitude
                            if dist < closestDist then
                                closestDist = dist
                                bestRock = v
                            end
                        end
                    end
                end
            end
        end
    elseif mode == "Global" then
        local targetOres = _G.SelectedGlobalOres
        if not targetOres or #targetOres == 0 then targetOres = {"Basalt Rock"} end
        
        -- Scan entire Rocks folder
        for _, folder in ipairs(rFolder:GetChildren()) do
            for _, v in ipairs(folder:GetChildren()) do
                if isRockValid(v, targetOres) then 
                     local dist = (v:GetPivot().Position - myPos).Magnitude
                     if dist < closestDist then
                         closestDist = dist
                         bestRock = v
                     end
                end
            end
        end
    end
    return bestRock
end

-- MINING LOOP (Uses Anchor for Anti-Jitter)
local function MineLoop(flag, mode)
    while _G[flag] do
        local rock = FindNearestOre(mode)
        if rock then
            local rockPivot = rock:GetPivot()
            -- Position: Under rock, looking up
            local minePos = rockPivot * CFrame.new(0, -6, 0)
            minePos = CFrame.lookAt(minePos.Position, rockPivot.Position)

            TweenTo(minePos)
            
            -- SWITCH TO ANCHOR MODE
            ToggleFloat(false)
            SetNoclip(true)
            
            if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
                lp.Character.HumanoidRootPart.CFrame = minePos
                lp.Character.HumanoidRootPart.Anchored = true
            end

            -- MINE UNTIL DEAD
            while _G[flag] and rock and rock.Parent and isRockValid(rock) do
                if not lp.Character then break end
                
                local char = lp.Character
                if not char:FindFirstChild("Pickaxe") then
                   local p = lp.Backpack:FindFirstChild("Pickaxe")
                   if p then char.Humanoid:EquipTool(p) end
                end

                pcall(function() ToolService:InvokeServer("Pickaxe") end)
                task.wait(0.1)
            end
            
            -- UNANCHOR
            if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
                lp.Character.HumanoidRootPart.Anchored = false
            end
        else
            -- No rock found
            if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
                lp.Character.HumanoidRootPart.Anchored = false
            end
            task.wait(1)
        end
        task.wait()
    end
    -- CLEANUP
    if lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
        lp.Character.HumanoidRootPart.Anchored = false
    end
    SetNoclip(false)
end

FarmTab:Dropdown({
    Title = "Select Cave",
    Values = { "Start Cave", "Middle Cave", "Danger Cave","Deep Cave", "Goblin Cave", "Volcanic Depths" },
    Value = "Start Cave",
    Callback = function(v) _G.SelectedCave = v end
})

FarmTab:Toggle({
    Title = "Auto Mine Cave",
    Desc = "Targets Nearest Rocks in Cave",
    Callback = function(state)
        _G.AutoCaveEnabled = state
        _G.AutoOreEnabled = false
        if not state and lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
             lp.Character.HumanoidRootPart.Anchored = false
        end
        if state then task.spawn(function() MineLoop("AutoCaveEnabled", "Cave") end) end
    end
})

-- GLOBAL ORES
local Section = FarmTab:Section({ Title = "Farm Rocks" })

FarmTab:Dropdown({
    Title = "Select Rock Types",
    Values = allOres,
    Value = { "Basalt Rock" },
    Multi = true,
    AllowNone = true,
    Callback = function(v) _G.SelectedGlobalOres = v end
})

FarmTab:Toggle({
    Title = "Auto Mine Ore",
    Desc = "Targets Nearest Rocks",
    Callback = function(state)
        _G.AutoOreEnabled = state
        _G.AutoCaveEnabled = false
        if not state and lp.Character and lp.Character:FindFirstChild("HumanoidRootPart") then
             lp.Character.HumanoidRootPart.Anchored = false
        end
        if state then task.spawn(function() MineLoop("AutoOreEnabled", "Global") end) end
    end
})

--------------------------------------------------------------------------------
-- FORGE TAB (NEW)
--------------------------------------------------------------------------------
local ForgeTab = Window:Tab({Title = "Forge"})

-- Forge Variables
local AutoForgeEnabled = false
local ForgeConnections = {}

-- FORGE HELPER FUNCTIONS --

-- Cleanup
local function cleanupMouse()
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0) 
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
end

-- 1. Hammer
local function clickHammerButton(button)
    local absPos = button.AbsolutePosition
    local absSize = button.AbsoluteSize
    local centerX = absPos.X + (absSize.X / 2)
    local centerY = absPos.Y + (absSize.Y / 2) + GuiService:GetGuiInset().Y
    
    VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, true, game, 1)
    task.wait(0.01)
    VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, false, game, 1)
end

local function handleHammerNote(noteObject)
    local innerFrame = noteObject:WaitForChild("Frame", 5)
    if not innerFrame then return end
    local circle = innerFrame:WaitForChild("Circle", 5)
    local border = innerFrame:WaitForChild("Border", 5)
    if not circle or not border then return end

    local targetSize = border.Size.X.Scale 
    local con
    con = RunService.RenderStepped:Connect(function()
        if not AutoForgeEnabled then 
            if con then con:Disconnect() end 
            return 
        end
        if not noteObject or not noteObject.Parent or not circle or not circle.Parent then
            if con then con:Disconnect() end
            return
        end
        if circle.Size.X.Scale <= (targetSize + 0.02) then
            if con then con:Disconnect() end
            clickHammerButton(noteObject)
        end
    end)
end

-- 2. Melt (Fast)
local isMelting = false
local function runMeltLoop()
    if isMelting then return end
    isMelting = true
    
    if not ForgeUI then ForgeUI = lp.PlayerGui:FindFirstChild("Forge") end
    if not ForgeUI or not ForgeUI:FindFirstChild("MeltMinigame") then 
        isMelting = false
        return 
    end

    local MeltMinigame = ForgeUI.MeltMinigame
    local Heater = MeltMinigame:WaitForChild("Heater")
    local Handle = Heater:WaitForChild("Top")
    local ProgressBar = MeltMinigame:WaitForChild("Bar")
    
    task.wait(0.3)

    while AutoForgeEnabled and MeltMinigame.Visible and ProgressBar.Area.AbsoluteSize.Y < (ProgressBar.Frame.AbsoluteSize.Y * 0.99) do
        local handlePos = Handle.AbsolutePosition
        local handleSize = Handle.AbsoluteSize
        local heaterSize = Heater.AbsoluteSize
        local insetY = GuiService:GetGuiInset().Y

        local startX = handlePos.X + (handleSize.X / 2)
        local startY = handlePos.Y + (handleSize.Y / 2) + insetY
        local endY = startY + (heaterSize.Y * 0.7) 

        VirtualInputManager:SendMouseMoveEvent(startX, startY, game)
        VirtualInputManager:SendMouseButtonEvent(startX, startY, 0, true, game, 1)
        
        local steps = 2 
        for i = 1, steps do
            local lerpY = startY + ((endY - startY) * (i / steps))
            VirtualInputManager:SendMouseMoveEvent(startX, lerpY, game)
            RunService.RenderStepped:Wait()
        end

        VirtualInputManager:SendMouseButtonEvent(startX, endY, 0, false, game, 1)
        RunService.RenderStepped:Wait()
    end
    isMelting = false
end

-- 3. Pour
local isPouring = false
local function runPourLoop()
    if isPouring then return end
    isPouring = true

    if not ForgeUI then ForgeUI = lp.PlayerGui:FindFirstChild("Forge") end
    if not ForgeUI or not ForgeUI:FindFirstChild("PourMinigame") then 
        isPouring = false
        return 
    end

    local PourMinigame = ForgeUI.PourMinigame
    local PourArea = PourMinigame.Frame.Area
    local PourLine = PourMinigame.Frame.Line

    while AutoForgeEnabled and isPouring and PourMinigame.Visible do
        local areaCenterY = PourArea.AbsolutePosition.Y + (PourArea.AbsoluteSize.Y / 2)
        local lineCenterY = PourLine.AbsolutePosition.Y + (PourLine.AbsoluteSize.Y / 2)
        
        if lineCenterY > areaCenterY then
            VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
        else
            VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
        end
        RunService.RenderStepped:Wait()
    end
    cleanupMouse()
    isPouring = false
end

-- 4. Mold
local function clickMoldUntilGone(moldModel)
    task.wait(0.2)
    while AutoForgeEnabled and moldModel and moldModel.Parent do
        local pivotCFrame = moldModel:GetPivot()
        local targetPosition = pivotCFrame.Position
        local vectorPos, onScreen = Camera:WorldToViewportPoint(targetPosition)
        
        if onScreen then
            VirtualInputManager:SendMouseButtonEvent(vectorPos.X, vectorPos.Y, 0, true, game, 1)
            task.wait(0.05)
            VirtualInputManager:SendMouseButtonEvent(vectorPos.X, vectorPos.Y, 0, false, game, 1)
        end
        task.wait(0.1) 
    end
end

ForgeTab:Section({ Title = "Auto Forge" })

ForgeTab:Toggle({
    Title = "Auto Forge Master",
    Desc = "Auto Hammer, Melt, Pour & Mold",
    Value = false,
    Callback = function(state) 
        AutoForgeEnabled = state
        
        -- Try to refresh reference just in case
        if not ForgeUI then ForgeUI = lp.PlayerGui:FindFirstChild("Forge") end

        if state and ForgeUI then
            -- 1. Hammer Listener
            if ForgeUI:FindFirstChild("HammerMinigame") then
                local hammerC = ForgeUI.HammerMinigame.ChildAdded:Connect(function(child)
                    if child.Name == "Frame" then handleHammerNote(child) end
                end)
                table.insert(ForgeConnections, hammerC)
            end
            
            -- 2. Melt Listener
            if ForgeUI:FindFirstChild("MeltMinigame") then
                local meltC = ForgeUI.MeltMinigame:GetPropertyChangedSignal("Visible"):Connect(function()
                    if ForgeUI.MeltMinigame.Visible then task.spawn(runMeltLoop) end
                end)
                table.insert(ForgeConnections, meltC)
            end

            -- 3. Pour Listener
            if ForgeUI:FindFirstChild("PourMinigame") then
                local pourC = ForgeUI.PourMinigame:GetPropertyChangedSignal("Visible"):Connect(function()
                    if ForgeUI.PourMinigame.Visible then
                        task.wait(0.5)
                        if ForgeUI.PourMinigame.Visible and AutoForgeEnabled then 
                            task.spawn(runPourLoop) 
                        end
                    else
                        isPouring = false
                    end
                end)
                table.insert(ForgeConnections, pourC)
            end
            
            -- 4. Mold Listener
            local moldC = Debris.ChildAdded:Connect(function(child)
                if child.Name == "Mold" then clickMoldUntilGone(child) end
            end)
            table.insert(ForgeConnections, moldC)

            -- Check Initial State (If enabled while already open)
            if ForgeUI:FindFirstChild("MeltMinigame") and ForgeUI.MeltMinigame.Visible then task.spawn(runMeltLoop) end
            if ForgeUI:FindFirstChild("PourMinigame") and ForgeUI.PourMinigame.Visible then 
                task.wait(0.5)
                if AutoForgeEnabled then task.spawn(runPourLoop) end
            end
            if Debris:FindFirstChild("Mold") then
                task.spawn(function() clickMoldUntilGone(Debris.Mold) end)
            end

        else
            -- Disconnect all events
            for _, v in pairs(ForgeConnections) do
                v:Disconnect()
            end
            ForgeConnections = {}
            
            -- Reset Flags
            isMelting = false
            isPouring = false
            cleanupMouse()
        end
    end
})

--------------------------------------------------------------------------------
-- SELL TAB (PRESERVED)
--------------------------------------------------------------------------------
local SellTab = Window:Tab({Title = "Sell Ores"})

local items = {
    "Iron","Gold","Silver","Cobalt","Titanium","Lapis Lazuli","Platinum","Boneite","Dark Boneite","Volcanic Rock",
    "Quartz","Amethyst","Topaz","Diamond","Sapphire","Slimite","Curpite","Obsidian",
    "Emerald","Ruby","Rivalite","Uranium","Mythril","Eye Ore","Fireite",
    "Magmaite","Lightite","Demonite","Darkryte"
}

local items1 = {
    "Magenta Crystal","Crimson Crystal","Greem Crystal","Orange Crystal","Blue Crystal",
    "Rainbow Crystal","Arcane Crystal"
}

SellTab:Button({
    Title = "Interact with Greedy Cey",
    Desc = "Press this to sell ores from anywhere. If the selected ores arenot selling press this again.",
    Callback = function()
        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ProximityService.RF.Dialogue:InvokeServer(workspace.Proximity["Greedy Cey"])
    end
})

-- AUTO SELL 1
local selectedItems = {}
local sellDelay = 5
SellTab:Section({ Title = "Auto Sell Island 2" })
SellTab:Dropdown({ Title = "Select Items", Values = items, Multi = true, Callback = function(v) selectedItems = v end })
SellTab:Slider({ Title = "Sell Delay", Value = {Min=1, Max=10, Default=5}, Callback = function(v) sellDelay = v end })
SellTab:Toggle({
    Title = "Enable Sell",
    Callback = function(state)
        _G.AutoSell1 = state
        if state then
            task.spawn(function()
                while _G.AutoSell1 do
                    for _, item in ipairs(selectedItems) do
                        if not _G.AutoSell1 then break end
                        pcall(function()
                             game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.DialogueService.RF.RunCommand:InvokeServer("SellConfirm", { Basket = {[item]=1} })
                        end)
                    end
                    task.wait(sellDelay)
                end
            end)
        end
    end
})

-- AUTO SELL 2 (Goblin)
local selectedItems2 = {}
local sellDelay2 = 5
SellTab:Section({ Title = "Auto Sell Goblin Cave" })
SellTab:Dropdown({ Title = "Goblin Items", Values = items1, Multi = true, Callback = function(v) selectedItems2 = v end })
SellTab:Slider({ Title = "Sell Delay", Value = {Min=1, Max=10, Default=5}, Callback = function(v) sellDelay2 = v end })
SellTab:Toggle({
    Title = "Enable Sell",
    Callback = function(state)
        _G.AutoSell2 = state
        if state then
            task.spawn(function()
                while _G.AutoSell2 do
                    for _, item in ipairs(selectedItems2) do
                        if not _G.AutoSell2 then break end
                        pcall(function()
                             game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.DialogueService.RF.RunCommand:InvokeServer("SellConfirm", { Basket = {[item]=1} })
                        end)
                    end
                    task.wait(sellDelay2)
                end
            end)
        end
    end
})

--------------------------------------------------------------------------------
-- POTION TAB
--------------------------------------------------------------------------------
local PotionTab = Window:Tab({Title = "Potion"})
local PotionMap = {
    ["Health Potion 2"]   = "HealthPotion2",
    ["Miner Potion 1"]    = "MinerPotion1",
    ["Speed Potion 1"]    = "MovementSpeedPotion1",
    ["Luck Potion 1"]     = "LuckPotion1",
    ["Damage Potion 1"]   = "AttackDamagePotion1"
}
local PotionList = {}
for n, _ in pairs(PotionMap) do table.insert(PotionList, n) end
table.sort(PotionList)

local buyName = "Health Potion 2"
local buyAmt = 1
PotionTab:Section({ Title = "Purchase" })
PotionTab:Dropdown({ Title = "Select Potion", Values = PotionList, Value = buyName, Callback = function(v) buyName = v end })
PotionTab:Slider({ Title = "Amount", Value = {Min=1,Max=10,Default=1}, Callback = function(v) buyAmt = v end })
PotionTab:Button({
    Title = "Buy Potion",
    Callback = function()
        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ProximityService.RF.Purchase:InvokeServer(PotionMap[buyName], buyAmt)
    end
})

local useName = "Health Potion 2"
PotionTab:Section({ Title = "Consume" })
PotionTab:Dropdown({ Title = "Select Potion", Values = PotionList, Value = useName, Callback = function(v) useName = v end })
PotionTab:Button({
    Title = "Use Potion",
    Callback = function()
        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ToolService.RF.ToolActivated:InvokeServer(PotionMap[useName])
    end
})

--------------------------------------------------------------------------------
-- TELEPORT TAB
--------------------------------------------------------------------------------
local TeleportTab = Window:Tab({Title = "Teleport"})
local TeleportLocations = {
    ["Spawn"] = CFrame.new(-211, 21, -47),
    ["Enhancer"] = CFrame.new(13, 22, -127),
    ["Rune Maker"] = CFrame.new(-47, 22, -139),
    ["Wizard"] = CFrame.new(96, 48, 137),
    ["Captain Rowan"] = CFrame.new(26, 75, -67),
    ["Ruined Cave"] = CFrame.new(81, 75, -50),
    ["Volcanic Cave"] = CFrame.new(390, 66, 71),
    ["Goblin Cave"] = CFrame.new(80, 21, -245),
}
local SelectedLoc = "Spawn"

local function DoTp()
    if TeleportLocations[SelectedLoc] then
        -- Use our smooth tween for teleports too
        TweenTo(TeleportLocations[SelectedLoc])
        task.wait(0.5)
        ToggleFloat(false)
    end
end

TeleportTab:Dropdown({
    Title = "Location",
    Values = {"Spawn", "Enhancer", "Rune Maker", "Wizard", "Captain Rowan", "Ruined Cave", "Goblin Cave", "Volcanic Cave"},
    Value = "Spawn",
    Callback = function(v) SelectedLoc = v if _G.TeleportToggleActive then DoTp() end end
})

TeleportTab:Toggle({
    Title = "Auto Teleport",
    Callback = function(state)
        _G.TeleportToggleActive = state
        if state then DoTp() end
    end
})

TeleportTab:Space()
TeleportTab:Button({
    Title = "Go to Stonewake's Cross",
    Callback = function()
        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.PortalService.RF.TeleportToIsland:InvokeServer("Stonewake's Cross")
    end
})

-- Fast Respawn Fix
if _G.TpConn then _G.TpConn:Disconnect() end
_G.TpConn = lp.CharacterAdded:Connect(function(c)
    if _G.TeleportToggleActive then
        c:WaitForChild("HumanoidRootPart", 10)
        task.wait(0.2)
        DoTp()
    end
end)

--------------------------------------------------------------------------------
-- MSC
--------------------------------------------------------------------------------
local MSCTab = Window:Tab({Title = "MSC"})

local afkConn = nil

local function setAntiAFK(state)
    if state then
        if afkConn then afkConn:Disconnect() end
        afkConn = lp.Idled:Connect(function()
            game:GetService("VirtualUser"):Button2Down(Vector2.zero, workspace.CurrentCamera.CFrame)
            task.wait(0.2)
            game:GetService("VirtualUser"):Button2Up(Vector2.zero, workspace.CurrentCamera.CFrame)
        end)
    else
        if afkConn then 
            afkConn:Disconnect() 
            afkConn = nil
        end
    end
end

-- Initialize Anti-AFK on script load
setAntiAFK(true)

MSCTab:Toggle({
    Title = "Anti-AFK",
    Value = true,
    Callback = function(state)
        setAntiAFK(state)
    end
})
