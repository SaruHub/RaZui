local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()

local Window = WindUI:CreateWindow({
    Title = "RaZui Hub",
    Folder = "MySuperHub",
    Size = UDim2.fromOffset(580, 460),
    MinSize = Vector2.new(560, 350),
    MaxSize = Vector2.new(850, 560),
    Transparent = true,
    Theme = "Dark",
    Resizable = true,
    SideBarWidth = 150,
    BackgroundImageTransparency = 0.42,
    HideSearchBar = true,
    ScrollBarEnabled = false,
})

Window:SetToggleKey(Enum.KeyCode.K)
Window:EditOpenButton({
    Title = "Open UI",
    CornerRadius = UDim.new(0,16),
    StrokeThickness = 2,
    Color = ColorSequence.new(Color3.fromHex("FF0F7B"), Color3.fromHex("F89B29")),
    OnlyMobile = false,
    Enabled = true,
    Draggable = true,
})

--------------------------------------------------------------------------------
-- SERVICES & UTILS
--------------------------------------------------------------------------------
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualInputManager = game:GetService("VirtualInputManager")
local GuiService = game:GetService("GuiService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")

local lp = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local Debris = Workspace:WaitForChild("Debris")
local PlayerGui = lp:WaitForChild("PlayerGui")
local ForgeUI = PlayerGui:WaitForChild("Forge", 10) 

-- Configuration
local MOVEMENT_SPEED = 65 
local NoclipConnection = nil
local RespawnTimer = 0
local LastTargetRock = nil -- Memory for death return

-- Defaults
_G.FarmPosition = "Below"
_G.TargetPriority = "Nearest"

-- HELPER: Check if Alive
local function IsAlive()
    local char = lp.Character
    if not char then return false end
    local hum = char:FindFirstChild("Humanoid")
    local root = char:FindFirstChild("HumanoidRootPart")
    return hum and root and hum.Health > 0
end

-- Track Respawn
lp.CharacterAdded:Connect(function()
    RespawnTimer = tick()
end)

-- HELPER: Get Farm Offset
local function GetFarmOffset()
    if _G.FarmPosition == "Above" then
        return CFrame.new(0, 7, 0)
    elseif _G.FarmPosition == "Beside" then
        return CFrame.new(0, 0, 6) 
    else -- Default "Below"
        return CFrame.new(0, -7, 0)
    end
end

-- 1. NOCLIP
local function SetNoclip(state)
    if state then
        if not NoclipConnection then
            NoclipConnection = RunService.Stepped:Connect(function()
                if IsAlive() then
                    for _, part in pairs(lp.Character:GetDescendants()) do
                        if part:IsA("BasePart") and part.CanCollide == true then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        end
    else
        if NoclipConnection then
            NoclipConnection:Disconnect()
            NoclipConnection = nil
        end
    end
end

-- 2. CAMERA NOCLIP
local function SetCameraNoclip(state)
    if state then
        lp.DevCameraOcclusionMode = Enum.DevCameraOcclusionMode.Invisicam
    else
        if not _G.AutoFarm and not _G.AutoCaveEnabled and not _G.AutoOreEnabled then
            lp.DevCameraOcclusionMode = Enum.DevCameraOcclusionMode.Zoom
        end
    end
end

-- 3. FLOAT
local function ToggleFloat(state)
    if not IsAlive() then return end
    local hrp = lp.Character.HumanoidRootPart
    local hum = lp.Character.Humanoid

    if state then
        hum.PlatformStand = true
        if not hrp:FindFirstChild("FarmFloat") then
            local bv = Instance.new("BodyVelocity")
            bv.Name = "FarmFloat"
            bv.Velocity = Vector3.new(0, 0, 0)
            bv.MaxForce = Vector3.new(100000, 100000, 100000)
            bv.Parent = hrp
        end
    else
        hum.PlatformStand = false
        local bv = hrp:FindFirstChild("FarmFloat")
        if bv then bv:Destroy() end
    end
end

-- 4. GYRO (To stand up straight when waiting)
local function ToggleGyro(state)
    if not IsAlive() then return end
    local hrp = lp.Character.HumanoidRootPart
    
    if state then
        if not hrp:FindFirstChild("StandUpGyro") then
            local bg = Instance.new("BodyGyro")
            bg.Name = "StandUpGyro"
            bg.MaxTorque = Vector3.new(400000, 400000, 400000)
            bg.P = 3000
            bg.D = 100
            local _, yRot, _ = hrp.CFrame:ToEulerAnglesYXZ()
            bg.CFrame = CFrame.fromEulerAnglesYXZ(0, yRot, 0)
            bg.Parent = hrp
        end
    else
        local bg = hrp:FindFirstChild("StandUpGyro")
        if bg then bg:Destroy() end
    end
end

-- 5. DEATH MONITOR
local function ConnectDeathMonitor(char)
    local hum = char:WaitForChild("Humanoid", 10)
    if hum then
        hum.Died:Connect(function()
            if char:FindFirstChild("HumanoidRootPart") then
                char.HumanoidRootPart.Anchored = true
                char.HumanoidRootPart.Velocity = Vector3.zero
                local bv = char.HumanoidRootPart:FindFirstChild("FarmFloat")
                if bv then bv:Destroy() end
                local bg = char.HumanoidRootPart:FindFirstChild("StandUpGyro")
                if bg then bg:Destroy() end
            end
        end)
    end
end

if lp.Character then ConnectDeathMonitor(lp.Character) end
lp.CharacterAdded:Connect(ConnectDeathMonitor)

-- 6. TWEEN
local function TweenTo(targetCFrame)
    if not IsAlive() then return end
    -- Safety Cooldown on Respawn
    if (tick() - RespawnTimer) < 6 then return end

    local hrp = lp.Character.HumanoidRootPart
    
    local distance = (hrp.Position - targetCFrame.Position).Magnitude
    local time = distance / MOVEMENT_SPEED
    
    if distance < 5 then
        hrp.CFrame = targetCFrame
        return
    end

    SetNoclip(true)
    ToggleFloat(true) 

    local tweenInfo = TweenInfo.new(time, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    local tween = TweenService:Create(hrp, tweenInfo, {CFrame = targetCFrame})
    
    tween:Play()
    
    local completed = false
    local conn = tween.Completed:Connect(function() completed = true end)
    
    while not completed do
        if not _G.AutoFarm and not _G.AutoCaveEnabled and not _G.AutoOreEnabled and not _G.TeleportToggleActive then
            tween:Cancel()
            ToggleFloat(false)
            break
        end

        if not IsAlive() then
            tween:Cancel()
            ToggleFloat(false)
            break
        end

        task.wait()
    end
    
    if conn then conn:Disconnect() end
end

-- 7. PRIORITY SORTER
local function SelectFromList(list, priority)
    if #list == 0 then return nil end
    
    if priority == "Random" then
        return list[math.random(1, #list)].obj
    elseif priority == "Prioritize Highest MaxHealth" then
        table.sort(list, function(a, b) return a.maxHp > b.maxHp end)
        return list[1].obj
    elseif priority == "Prioritize Lowest MaxHealth" then
        table.sort(list, function(a, b) return a.maxHp < b.maxHp end)
        return list[1].obj
    else -- Default to Nearest
        table.sort(list, function(a, b) return a.dist < b.dist end)
        return list[1].obj
    end
end

--------------------------------------------------------------------------------
-- FARM TAB
--------------------------------------------------------------------------------

local FarmTab = Window:Tab({Title = "Farm"})
FarmTab:Select()

local Section = FarmTab:Section({ Title = "Settings" })

FarmTab:Dropdown({
    Title = "Farming Position",
    Values = {"Below", "Above", "Beside"},
    Value = "Below",
    Callback = function(v) 
        _G.FarmPosition = v 
    end
})

FarmTab:Dropdown({
    Title = "Target Priority (Mobs & Ores)",
    Values = { "Nearest", "Random", "Prioritize Highest MaxHealth", "Prioritize Lowest MaxHealth" },
    Value = "Nearest",
    Callback = function(v) 
        _G.TargetPriority = v 
    end
})

local Section = FarmTab:Section({ Title = "Farm Mobs" })

_G.SelectedNPCs = { "Zombie" }

local function GetBaseName(displayName)
    if not displayName then return "" end
    return displayName:match("^(.-)%s*%(Level:") or displayName
end

local Dropdown = FarmTab:Dropdown({
    Title = "Select MOBs to Farm",
    Values = { "Zombie", "Delver Zombie", "Brute Zombie" },
    Value = { "Zombie" },
    Multi = true,
    AllowNone = true,
    Callback = function(optionsTable) 
        _G.SelectedNPCs = optionsTable or {}
    end
})

local Toggle = FarmTab:Toggle({
    Title = "Auto Farm MOBs",
    Desc = "Targets Selected MOBs",
    Value = false,
    Callback = function(state)
        _G.AutoFarm = state
        SetCameraNoclip(state) 
        
        if not state then
            SetNoclip(false)
            ToggleFloat(false)
            ToggleGyro(false)
            SetCameraNoclip(false) 
            return
        end

        task.spawn(function()
            while _G.AutoFarm do
                -- 1. SAFETY CHECK: Dead or respawning
                if not IsAlive() or (tick() - RespawnTimer) < 6 then
                    SetNoclip(false)
                    ToggleFloat(false)
                    ToggleGyro(false)
                    task.wait(0.5) 
                    continue 
                end

                if #_G.SelectedNPCs == 0 then
                    ToggleFloat(true)
                    task.wait(1)
                    continue
                end
                
                local validTargets = {}
                local myPos = lp.Character.HumanoidRootPart.Position

                if workspace:FindFirstChild("Living") then
                    for _, v in pairs(workspace.Living:GetChildren()) do
                        if v:GetAttribute("IsNpc") == true and v:FindFirstChild("Humanoid") and v:FindFirstChild("HumanoidRootPart") then
                            local h = v.Humanoid
                            if h.Health > 0 then
                                local baseName = GetBaseName(h.DisplayName)
                                local match = false
                                for _, s in ipairs(_G.SelectedNPCs) do
                                    if s == baseName then match = true break end
                                end
                                
                                if match then
                                    local dist = (myPos - v.HumanoidRootPart.Position).Magnitude
                                    table.insert(validTargets, {
                                        obj = v,
                                        dist = dist,
                                        maxHp = h.MaxHealth or 100
                                    })
                                end
                            end
                        end
                    end
                end

                local target = SelectFromList(validTargets, _G.TargetPriority)

                if target then
                    ToggleGyro(false)

                    local tRoot = target.HumanoidRootPart
                    local attackCFrame = tRoot.CFrame * GetFarmOffset() 
                    attackCFrame = CFrame.lookAt(attackCFrame.Position, tRoot.Position)

                    TweenTo(attackCFrame)
                    
                    if not IsAlive() then continue end

                    ToggleFloat(true) 
                    SetNoclip(true)

                    while _G.AutoFarm and target and target.Parent and target.Humanoid.Health > 0 do
                        if not IsAlive() then break end
                        
                        local tPos = target.HumanoidRootPart.Position
                        local goalPos = target.HumanoidRootPart.CFrame * GetFarmOffset()
                        lp.Character.HumanoidRootPart.CFrame = CFrame.lookAt(goalPos.Position, tPos)
                        lp.Character.HumanoidRootPart.Velocity = Vector3.zero

                        local char = lp.Character
                        if not char:FindFirstChildWhichIsA("Tool") then
                            local tool = lp.Backpack:FindFirstChild("Weapon") or lp.Backpack:FindFirstChildWhichIsA("Tool")
                            if tool then char.Humanoid:EquipTool(tool) end
                        end

                        pcall(function()
                            game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ToolService.RF.ToolActivated:InvokeServer("Weapon")
                        end)
                        task.wait()
                    end
                else
                    -- NO TARGET: Float in place
                    if IsAlive() then
                        SetNoclip(true)
                        ToggleFloat(true)
                        ToggleGyro(true) -- Stand straight
                        lp.Character.HumanoidRootPart.Velocity = Vector3.zero
                    end
                    task.wait(0.5)
                end
                task.wait()
            end
            ToggleFloat(false)
            ToggleGyro(false)
            SetNoclip(false)
            SetCameraNoclip(false)
        end)
    end
})

--------------------------------------------------------------------------------
-- ORE / CAVE FARMING
--------------------------------------------------------------------------------

local Section = FarmTab:Section({ Title = "Mining (Caves & Ores)" })

local ToolService = ReplicatedStorage:WaitForChild("Shared"):WaitForChild("Packages"):WaitForChild("Knit"):WaitForChild("Services"):WaitForChild("ToolService"):WaitForChild("RF"):WaitForChild("ToolActivated")

local caves = {
    ["Start Cave"] = { folder = "Island1CaveStart", ores = {"Pebble"} },
    ["Middle Cave"] = { folder = "Island1CaveMid", ores = {"Rock"} },
    ["Deep Cave"] =  { folder = "Island1CaveDeep", ores = {"Rock", "Boulder"} },
    ["Roof"] =       { folder = "Roof", ores = {"Lucky Block"} }
}
local allOres = {"Pebble", "Rock", "Boulder", "Lucky Block"}

local RockBlacklist = {} -- [Instance] = tick()

local function isRockValid(model, oreList, checkFullHealth)
    if not model or not model.Parent then return false, 0 end
    
    -- BLACKLIST CHECK
    if RockBlacklist[model] then
        if (tick() - RockBlacklist[model]) < 30 then 
            return false, 0 
        else
            RockBlacklist[model] = nil 
        end
    end

    local nameMatch = false
    if oreList then
        for _, name in ipairs(oreList) do
            if model.Name == name or model:FindFirstChild(name) then nameMatch = true break end
        end
    else
        nameMatch = true
    end
    if not nameMatch then return false, 0 end

    local hPart = nil
    for _, c in ipairs(model:GetChildren()) do
        if c:GetAttribute("Health") then hPart = c break end
    end
    
    if hPart then
        local hp = hPart:GetAttribute("Health")
        local maxHp = hPart:GetAttribute("MaxHealth") or 100

        if not hp or hp <= 0 then return false, 0 end

        if checkFullHealth then
            if hp < maxHp then return false, 0 end
        end

        return true, maxHp
    end
    return false, 0
end

local function FindBestOre(mode)
    if not IsAlive() then return nil end
    local rFolder = workspace:FindFirstChild("Rocks")
    if not rFolder then return nil end

    local myPos = lp.Character.HumanoidRootPart.Position
    local candidates = {}

    if mode == "Cave" then
        local data = caves[_G.SelectedCave or "Start Cave"]
        local f = rFolder:FindFirstChild(data.folder)
        if f then
            for _, v in ipairs(f:GetChildren()) do
                local valid, maxHp = isRockValid(v, data.ores, true)
                if valid then 
                    table.insert(candidates, {
                        obj = v,
                        dist = (v:GetPivot().Position - myPos).Magnitude,
                        maxHp = maxHp
                    })
                end
            end
        end
    elseif mode == "Global" then
        local targetOres = _G.SelectedGlobalOres
        if not targetOres or #targetOres == 0 then targetOres = {"Pebble"} end

        for _, folder in ipairs(rFolder:GetChildren()) do
            for _, v in ipairs(folder:GetChildren()) do
                local valid, maxHp = isRockValid(v, targetOres, true)
                if valid then 
                    table.insert(candidates, {
                        obj = v,
                        dist = (v:GetPivot().Position - myPos).Magnitude,
                        maxHp = maxHp
                    })
                end
            end
        end
    end
    return SelectFromList(candidates, _G.TargetPriority)
end

local function MineLoop(flag, mode)
    while _G[flag] do
        -- 1. SAFETY CHECK: Dead or respawning
        if not IsAlive() or (tick() - RespawnTimer) < 6 then
            SetNoclip(false)
            ToggleFloat(false)
            ToggleGyro(false)
            task.wait(0.5) 
            continue 
        end

        local rock = nil

        -- 2. RETURN TO DEATH SPOT LOGIC
        if LastTargetRock and LastTargetRock.Parent then
            if isRockValid(LastTargetRock, nil, false) then
                 rock = LastTargetRock
            else
                 LastTargetRock = nil
            end
        else
            LastTargetRock = nil
        end

        if not rock then
            rock = FindBestOre(mode)
        end
        
        if rock then
            LastTargetRock = rock
            ToggleGyro(false)

            local rockPivot = rock:GetPivot()
            local minePos = rockPivot * GetFarmOffset()
            minePos = CFrame.lookAt(minePos.Position, rockPivot.Position)

            TweenTo(minePos)
            
            if not IsAlive() then 
                SetNoclip(false)
                ToggleFloat(false)
                continue 
            end

            ToggleFloat(false)
            SetNoclip(true)
            
            if IsAlive() then
                lp.Character.HumanoidRootPart.CFrame = minePos
                lp.Character.HumanoidRootPart.Anchored = true
            end

            local startMiningTime = tick()
            local BUGGED_TIMEOUT = 6 

            while _G[flag] and rock and rock.Parent do
                local valid, _ = isRockValid(rock)
                if not valid then break end

                if not IsAlive() then break end
                
                local hPart = nil
                for _, c in ipairs(rock:GetChildren()) do
                    if c:GetAttribute("Health") then hPart = c break end
                end
                
                if hPart then
                    local curHp = hPart:GetAttribute("Health") or 100
                    local maxHp = hPart:GetAttribute("MaxHealth") or 100
                    
                    if (tick() - startMiningTime) > BUGGED_TIMEOUT then
                        if curHp >= maxHp then
                            RockBlacklist[rock] = tick()
                            LastTargetRock = nil
                            break 
                        end
                    end
                end

                local char = lp.Character
                if not char:FindFirstChild("Pickaxe") then
                   local p = lp.Backpack:FindFirstChild("Pickaxe")
                   if p then char.Humanoid:EquipTool(p) end
                end

                pcall(function() ToolService:InvokeServer("Pickaxe") end)
                task.wait(0.1)
            end
            
            if not rock.Parent then
                 LastTargetRock = nil
            end

            if IsAlive() then
                lp.Character.HumanoidRootPart.Anchored = false
            end
        else
            -- NO TARGET: Float in place
            if IsAlive() then
                lp.Character.HumanoidRootPart.Anchored = false
                SetNoclip(true)
                ToggleFloat(true)
                ToggleGyro(true) -- Stand straight
                lp.Character.HumanoidRootPart.Velocity = Vector3.zero
            end
            task.wait(1)
        end
        task.wait()
    end
    LastTargetRock = nil
    if IsAlive() then
        lp.Character.HumanoidRootPart.Anchored = false
    end
    SetNoclip(false)
    ToggleFloat(false)
    ToggleGyro(false)
    SetCameraNoclip(false)
end

FarmTab:Dropdown({
    Title = "Select Cave",
    Values = {"Start Cave", "Middle Cave", "Deep Cave", "Roof"},
    Value = "Start Cave",
    Callback = function(v) _G.SelectedCave = v end
})

FarmTab:Toggle({
    Title = "Auto Mine Cave",
    Desc = "Targets Rocks in Cave",
    Callback = function(state)
        _G.AutoCaveEnabled = state
        _G.AutoOreEnabled = false
        LastTargetRock = nil
        SetCameraNoclip(state)
        
        if not state and IsAlive() then
             lp.Character.HumanoidRootPart.Anchored = false
             SetCameraNoclip(false)
             ToggleFloat(false)
             ToggleGyro(false)
             SetNoclip(false)
        end
        if state then task.spawn(function() MineLoop("AutoCaveEnabled", "Cave") end) end
    end
})

FarmTab:Space()

FarmTab:Dropdown({
    Title = "Select Rock Types",
    Values = allOres,
    Value = { "Pebble" },
    Multi = true,
    AllowNone = true,
    Callback = function(v) _G.SelectedGlobalOres = v end
})

FarmTab:Toggle({
    Title = "Auto Mine Ore (Global)",
    Desc = "Targets Nearest Rock",
    Callback = function(state)
        _G.AutoOreEnabled = state
        _G.AutoCaveEnabled = false
        LastTargetRock = nil
        SetCameraNoclip(state)

        if not state and IsAlive() then
             lp.Character.HumanoidRootPart.Anchored = false
             SetCameraNoclip(false)
             ToggleFloat(false)
             ToggleGyro(false)
             SetNoclip(false)
        end
        if state then task.spawn(function() MineLoop("AutoOreEnabled", "Global") end) end
    end
})

--------------------------------------------------------------------------------
-- FORGE TAB
--------------------------------------------------------------------------------
local ForgeTab = Window:Tab({Title = "Forge"})

local AutoForgeEnabled = false
local ForgeConnections = {}

local function cleanupMouse()
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0) 
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
end

local function getInsetY()
    if UserInputService.TouchEnabled and not UserInputService.MouseEnabled then
        return 0 
    else
        return GuiService:GetGuiInset().Y 
    end
end

local function clickVisualTarget(targetElement)
    if not targetElement or not targetElement.Parent then return end
    local absPos = targetElement.AbsolutePosition
    local absSize = targetElement.AbsoluteSize
    local centerX = absPos.X + (absSize.X / 2)
    local centerY = absPos.Y + (absSize.Y / 2) + getInsetY()
    
    VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, true, game, 1)
    task.wait(0.05) 
    VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, false, game, 1)
end

local function handleHammerNote(noteObject)
    local innerFrame = noteObject:WaitForChild("Frame", 5)
    if not innerFrame then return end
    local circle = innerFrame:WaitForChild("Circle", 5)
    local border = innerFrame:WaitForChild("Border", 5)
    if not circle or not border then return end

    local targetSize = border.Size.X.Scale 
    local con
    con = RunService.RenderStepped:Connect(function()
        if not AutoForgeEnabled then 
            if con then con:Disconnect() end 
            return 
        end
        if not noteObject or not noteObject.Parent or not circle or not circle.Parent then
            if con then con:Disconnect() end
            return
        end
        if circle.Size.X.Scale <= (targetSize + 0.02) then
            if con then con:Disconnect() end
            clickVisualTarget(border)
        end
    end)
end

local isMelting = false
local function runMeltLoop()
    if isMelting then return end
    isMelting = true
    if not ForgeUI or not ForgeUI:FindFirstChild("MeltMinigame") then 
        isMelting = false
        return 
    end
    local MeltMinigame = ForgeUI.MeltMinigame
    local Heater = MeltMinigame:WaitForChild("Heater")
    local Handle = Heater:WaitForChild("Top")
    local ProgressBar = MeltMinigame:WaitForChild("Bar")
    
    task.wait(0.3)
    
    while AutoForgeEnabled and MeltMinigame.Visible and ProgressBar.Area.AbsoluteSize.Y < (ProgressBar.Frame.AbsoluteSize.Y * 0.99) do
        local handlePos = Handle.AbsolutePosition
        local handleSize = Handle.AbsoluteSize
        
        local startX = handlePos.X + (handleSize.X / 2)
        local startY = handlePos.Y + (handleSize.Y / 2) + getInsetY()
        
        local targetRawY = handlePos.Y + (handlePos.Y * 0.50)
        local endY = targetRawY + (handleSize.Y / 2) + getInsetY()

        VirtualInputManager:SendMouseMoveEvent(startX, startY, game)
        task.wait(0.05) 

        VirtualInputManager:SendMouseButtonEvent(startX, startY, 0, true, game, 1)
        task.wait(0.05) 
        
        local steps = 0.01 
        for i = 0.01, steps do
            local lerpY = startY + ((endY - startY) * (i / steps))
            VirtualInputManager:SendMouseMoveEvent(startX, lerpY, game)
            RunService.RenderStepped:Wait()
        end
        
        task.wait(0.05) 

        for i = 0.01, steps do
            local lerpY = endY + ((startY - endY) * (i / steps)) 
            VirtualInputManager:SendMouseMoveEvent(startX, lerpY, game)
            RunService.RenderStepped:Wait()
        end

        task.wait(0.05)
        
        VirtualInputManager:SendMouseButtonEvent(startX, startY, 0, false, game, 1)
        
        task.wait(0.1)
    end
    isMelting = false
end

local isPouring = false
local function runPourLoop()
    if isPouring then return end
    isPouring = true
    if not ForgeUI or not ForgeUI:FindFirstChild("PourMinigame") then 
        isPouring = false
        return 
    end
    local PourMinigame = ForgeUI.PourMinigame
    local PourArea = PourMinigame.Frame.Area
    local PourLine = PourMinigame.Frame.Line
    while AutoForgeEnabled and isPouring and PourMinigame.Visible do
        local areaCenterY = PourArea.AbsolutePosition.Y + (PourArea.AbsoluteSize.Y / 2)
        local lineCenterY = PourLine.AbsolutePosition.Y + (PourLine.AbsoluteSize.Y / 2)
        if lineCenterY > areaCenterY then
            VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
        else
            VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
        end
        RunService.RenderStepped:Wait()
    end
    cleanupMouse()
    isPouring = false
end

local function clickMoldUntilGone(moldModel)
    task.wait(0.2)
    while AutoForgeEnabled and moldModel and moldModel.Parent do
        local pivotCFrame = moldModel:GetPivot()
        local targetPosition = pivotCFrame.Position
        local vectorPos, onScreen = Camera:WorldToViewportPoint(targetPosition)
        if onScreen then
            VirtualInputManager:SendMouseButtonEvent(vectorPos.X, vectorPos.Y, 0, true, game, 1)
            task.wait(0.05)
            VirtualInputManager:SendMouseButtonEvent(vectorPos.X, vectorPos.Y, 0, false, game, 1)
        end
        task.wait(0.1) 
    end
end

ForgeTab:Section({ Title = "Auto Forge" })

ForgeTab:Toggle({
    Title = "Auto Forge Master",
    Desc = "Auto Hammer, Melt, Pour & Mold",
    Value = false,
    Callback = function(state) 
        AutoForgeEnabled = state
        
        if state then
            if ForgeUI:FindFirstChild("HammerMinigame") then
                local hammerC = ForgeUI.HammerMinigame.ChildAdded:Connect(function(child)
                    if child.Name == "Frame" then handleHammerNote(child) end
                end)
                table.insert(ForgeConnections, hammerC)
            end
            if ForgeUI:FindFirstChild("MeltMinigame") then
                local meltC = ForgeUI.MeltMinigame:GetPropertyChangedSignal("Visible"):Connect(function()
                    if ForgeUI.MeltMinigame.Visible then task.spawn(runMeltLoop) end
                end)
                table.insert(ForgeConnections, meltC)
            end
            if ForgeUI:FindFirstChild("PourMinigame") then
                local pourC = ForgeUI.PourMinigame:GetPropertyChangedSignal("Visible"):Connect(function()
                    if ForgeUI.PourMinigame.Visible then
                        task.wait(0.5)
                        if ForgeUI.PourMinigame.Visible and AutoForgeEnabled then 
                            task.spawn(runPourLoop) 
                        end
                    else
                        isPouring = false
                    end
                end)
                table.insert(ForgeConnections, pourC)
            end
            local moldC = Debris.ChildAdded:Connect(function(child)
                if child.Name == "Mold" then clickMoldUntilGone(child) end
            end)
            table.insert(ForgeConnections, moldC)

            if ForgeUI:FindFirstChild("MeltMinigame") and ForgeUI.MeltMinigame.Visible then task.spawn(runMeltLoop) end
            if ForgeUI:FindFirstChild("PourMinigame") and ForgeUI.PourMinigame.Visible then 
                task.wait(0.5)
                if AutoForgeEnabled then task.spawn(runPourLoop) end
            end
            if Debris:FindFirstChild("Mold") then
                task.spawn(function() clickMoldUntilGone(Debris.Mold) end)
            end
        else
            for _, v in pairs(ForgeConnections) do v:Disconnect() end
            ForgeConnections = {}
            isMelting = false
            isPouring = false
            cleanupMouse()
        end
    end
})

--------------------------------------------------------------------------------
-- SELL TAB
--------------------------------------------------------------------------------
local SellTab = Window:Tab({Title = "Sell Ores"})
local sellDelay = 5
local selectedItems = {}

SellTab:Button({
    Title = "Interact with Greedy Cey",
    Desc = "Press this to sell ores from anywhere. If the selected ores arenot selling press this again.",
    Callback = function()
        local args = { workspace:WaitForChild("Proximity"):WaitForChild("Greedy Cey") }
        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ProximityService.RF.Dialogue:InvokeServer(unpack(args))
    end
})

local items = {
    "Stone","Sand Stone","Copper","Iron","Tin","Silver","Gold",
    "Mushroomite","Platinum","Bananite","Cardboardite","Aite","Poopite"
}

SellTab:Section({ Title = "Auto Sell Island 1" })
SellTab:Dropdown({
    Title = "Select Items",
    Values = items,
    Value = {},
    Multi = true,
    Callback = function(v) selectedItems = v end
})

SellTab:Slider({
    Title = "Sell Delay",
    Value = {Min = 1, Max = 10, Default = 5},
    Callback = function(v) sellDelay = v end
})

SellTab:Toggle({
    Title = "Enable Sell",
    Callback = function(state)
        _G.AutoSell = state
        if state then
            task.spawn(function()
                while _G.AutoSell do
                    if #selectedItems > 0 then
                        for _, item in ipairs(selectedItems) do
                            if not _G.AutoSell then break end
                            pcall(function()
                                local basket = {[item] = 1}
                                game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.DialogueService.RF.RunCommand:InvokeServer("SellConfirm", { Basket = basket })
                            end)
                        end
                    end
                    task.wait(sellDelay)
                end
            end)
        end
    end
})

--------------------------------------------------------------------------------
-- POTION TAB (UNCHANGED)
--------------------------------------------------------------------------------
local PotionTab = Window:Tab({Title = "Potion"})

local NameMap = {
    ["Health Potion 1"] = "HealthPotion1",
    ["Miner Potion 1"]  = "MinerPotion1",
    ["Speed Potion 1"]  = "MovementSpeedPotion1",
    ["Luck Potion 1"]   = "LuckPotion1",
    ["Damage Potion 1"] = "AttackDamagePotion1",
}
local potionList = {}
for _, v in pairs(NameMap) do table.insert(potionList, v) end
table.sort(potionList)
local selectedPotion = "HealthPotion1"
local buyAmount = 1

PotionTab:Section({ Title = "Purchase" })
PotionTab:Dropdown({ Title = "Select Potion", Values = potionList, Value = selectedPotion, Callback = function(v) selectedPotion = v end })
PotionTab:Slider({ Title = "Amount", Value = {Min = 1, Max = 10, Default = 1}, Callback = function(v) buyAmount = v end })
PotionTab:Button({
    Title = "Buy Potion",
    Callback = function()
        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ProximityService.RF.Purchase:InvokeServer(selectedPotion, buyAmount)
    end
})

local displayList = {}
for k, _ in pairs(NameMap) do table.insert(displayList, k) end
table.sort(displayList)
local selectedDisplay = "Health Potion 1"

PotionTab:Section({ Title = "Consume" })
PotionTab:Dropdown({ Title = "Select Potion", Values = displayList, Value = selectedDisplay, Callback = function(v) selectedDisplay = v end })
PotionTab:Button({
    Title = "Use Potion",
    Callback = function()
        local real = NameMap[selectedDisplay]
        if real then game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.ToolService.RF.ToolActivated:InvokeServer(real) end
    end
})

--------------------------------------------------------------------------------
-- TELEPORT TAB
--------------------------------------------------------------------------------
local TeleportTab = Window:Tab({Title = "Teleport"})

local TeleportLocations = {
    ["Spawn"] = CFrame.new(-220, 37, 173),
    ["Enhancer"] = CFrame.new(-260, 20, 33),
    ["Rune Maker"] = CFrame.new(-270, 20, 138),
    ["Wizard"] = CFrame.new(-20, 81, -350),
}
local SelectedLocation = "Spawn"

local function DoTeleport()
    if TeleportLocations[SelectedLocation] then
        TweenTo(TeleportLocations[SelectedLocation])
        task.wait(0.5)
        ToggleFloat(false)
    end
end

TeleportTab:Dropdown({
    Title = "Location",
    Values = {"Spawn", "Enhancer", "Rune Maker", "Wizard"},
    Value = "Spawn",
    Callback = function(v) SelectedLocation = v if _G.TeleportToggleActive then DoTeleport() end end
})

TeleportTab:Toggle({
    Title = "Auto Teleport",
    Callback = function(state)
        _G.TeleportToggleActive = state
        if state then DoTeleport() end
    end
})

TeleportTab:Space()
TeleportTab:Button({
    Title = "Go to Forgotten Kingdom",
    Callback = function()
        game:GetService("ReplicatedStorage").Shared.Packages.Knit.Services.PortalService.RF.TeleportToIsland:InvokeServer("Forgotten Kingdom")
    end
})

--------------------------------------------------------------------------------
-- MSC
--------------------------------------------------------------------------------
local MSCTab = Window:Tab({Title = "MSC"})

local afkConn = nil

local function setAntiAFK(state)
    if state then
        if afkConn then afkConn:Disconnect() end
        afkConn = lp.Idled:Connect(function()
            game:GetService("VirtualUser"):Button2Down(Vector2.zero, workspace.CurrentCamera.CFrame)
            task.wait(0.2)
            game:GetService("VirtualUser"):Button2Up(Vector2.zero, workspace.CurrentCamera.CFrame)
        end)
    else
        if afkConn then 
            afkConn:Disconnect() 
            afkConn = nil
        end
    end
end

setAntiAFK(true)

MSCTab:Toggle({
    Title = "Anti-AFK",
    Value = true,
    Callback = function(state)
        setAntiAFK(state)
    end
})

--------------------------------------------------------------------------------
-- HIDE NAME LOGIC (ADDED)
--------------------------------------------------------------------------------
local isNameHidden = false

local function updateNameVisibility(character)
    if not character then return end
    task.wait(0.2) 
    
    local humanoid = character:FindFirstChild("Humanoid")
    local head = character:FindFirstChild("Head")

    if isNameHidden then
        if humanoid then
            humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
            humanoid.NameOcclusion = Enum.NameOcclusion.OccludeAll
        end
        if head then
            for _, v in pairs(head:GetChildren()) do
                if v:IsA("BillboardGui") or v:IsA("SurfaceGui") then
                    v.Enabled = false
                end
            end
        end
    else
        if humanoid then
            humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
        end
        if head then
            for _, v in pairs(head:GetChildren()) do
                if v:IsA("BillboardGui") or v:IsA("SurfaceGui") then
                    v.Enabled = true
                end
            end
        end
    end
end

MSCTab:Section({ Title = "Character" })
MSCTab:Toggle({
    Title = "Hide Name",
    Description = "Hides overhead name (Note: Usually Client-Sided)",
    Callback = function(state)
        isNameHidden = state
        updateNameVisibility(lp.Character)
    end
})

lp.CharacterAdded:Connect(function(newChar)
    if isNameHidden then
        task.wait(1) 
        updateNameVisibility(newChar)
    end
end)
